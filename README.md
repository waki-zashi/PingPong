# Beer Pong 5×5 — Межпроцессное взаимодействие через Unix Domain Sockets

Лабораторная работа  
«Архитектура ЭВМ и операционные системы»  
Тема: Реализация взаимодействия двух процессов с помощью Unix domain sockets (AF_UNIX)

## Правила игры

- Игровое поле — 5 × 5 клеток.
- У каждого игрока ровно 5 стаканов пива, расставленных в случайных неповторяющихся клетках.
- Игроки ходят по очереди. Первый ход всегда делает клиент.
- За ход игрок выбирает любую клетку поля противника и «кидает мячик» (отправляет координаты).
- Возможные результаты выстрела:
  - MISS — промах (клетка пуста или уже обстреляна)
  - HIT  — попал в стакан, но у противника остались живые стаканы
  - SUNK — попал в последний стакан → немедленная победа
- Игра заканчивается только при получении сообщения SUNK.
- Между получением выстрела противника и отправкой своего выстрела — задержка ровно 1 секунда.

## Техническая реализация

### 1. Технология обмена данными

Используются Unix domain sockets в потоковом режиме (AF_UNIX + SOCK_STREAM):

```
socket(AF_UNIX, SOCK_STREAM, 0)
```

- Сервер создаёт сокет, привязывает его к пути /tmp/pingpong.sock, переходит в режим прослушивания и ожидает одного подключения (listen(..., 1)).
- Клиент подключается к тому же пути.
- После accept() у сервера и connect() у клиента образуется полноценный двунаправленный потоковый канал, аналогичный TCP-соединению, но работающий только внутри одной машины.

Преимущества:
  - отсутствие сетевого стека → минимальная задержка
  - передача дескрипторов возможна (хотя в данной работе не используется)
  - надёжная доставка и сохранение порядка сообщений

### 2. Протокол обмена

Простой текстовый протокол поверх потока:

| Направление       | Сообщение                | Ответ                     |
|-------------------|--------------------------|---------------------------|
| Любой → Любой     | SHOT x,y\n             | —                         |
| Любой → Любой     | —                        | HIT\n / MISS\n / SUNK\n   |

Важно: каждое сообщение обязательно завершается символом '\n'.  
Это гарантирует корректную работу функции посимвольного чтения read_line().

### 3. Логика игры (структура Game)

```cpp
struct Game {
    std::vector<std::pair<int,int>> cups;           // мои стаканы
    std::set<std::pair<int,int>> hit_by_opponent;   // клетки, куда попал противник
    std::set<std::pair<int,int>> my_shots;          // клетки, куда я уже стрелял
};
```

- place_cups() — случайным образом расставляет 5 стаканов без пересечений.
- receive_shot(x,y) возвращает строку результата и обновляет hit_by_opponent.
- make_shot() выбирает случайную клетку, в которую игрок ещё не стрелял.

### 4. Основной цикл и синхронизация ходов

- Клиент начинает игру (my_turn = true у клиента, false у сервера).
- Каждый процесс строго чередует:
  1. Отправка своего выстрела (если его очередь)
  2. Ожидание и обработка выстрела противника
- После обработки чужого выстрела и отправки результата вызывается sleep_for(1s) — требуемая пауза 1 секунда.

### 5. Обработка исключений и гарантированное завершение

- Функция read_line() возвращает false при обрыве соединения или ошибке чтения → немедленный выход из главного цикла.
- При получении результата SUNK оба процесса:
  - выводят сообщение о победе/поражении
  - выполняют delay() (чтобы сообщение успело появиться)
  - делают break из цикла
- В блоке finally (в main) всегда вызываются:
  - close() для всех файловых дескрипторов
  - unlink("/tmp/pingpong.sock") у сервера
- Благодаря строгому протоколу и обязательному символу '\n' «зависание на чтении» невозможно.

### 6. Компиляция и запуск

```bash
g++ -std=c++17 -pthread server.cpp -o server
g++ -std=c++17 -pthread client.cpp -o client

# Терминал 1
./server

# Терминал 2
./client
```

## Вывод

Работа демонстрирует корректное использование Unix domain sockets для организации надёжного синхронного межпроцессного взаимодействия, разработку простого, но отказоустойчивого текстового протокола, а также грамотную обработку всех граничных ситуаций, что гарантирует отсутствие взаимных блокировок и утечек ресурсов.
